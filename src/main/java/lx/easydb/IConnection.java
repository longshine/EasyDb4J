package lx.easydb;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.*;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import lx.easydb.criterion.Criteria;
import lx.easydb.mapping.Column;
import lx.easydb.mapping.Table;

/**
 * Represents a {@link Connection} with extended methods of
 * entity query and criterion query.
 * 
 * @author Long
 *
 */
public interface IConnection extends Connection {
	/**
	 * Gets the underlying associated {@link Connection}.
	 */
	Connection getConnection();
	/**
	 * Executes the SQL query and returns the {@link ResultSet} object generated by the query.
	 * @param sql an SQL statement
	 * @return a {@link ResultSet} object that contains the data produced by the query; never null
	 * @see {@link PreparedStatement#executeQuery()}
	 */
	ResultSet executeQuery(String sql) throws SQLException;
	/**
	 * Executes the SQL query and returns the {@link ResultSet} object generated by the query.
	 * @param sql an SQL statement
	 * @param params the values of params in the statement
	 * @return a {@link ResultSet} object that contains the data produced by the query; never null
	 * @see {@link PreparedStatement#executeQuery()}
	 */
	ResultSet executeQuery(String sql, Object[] params) throws SQLException;
	/**
	 * Executes the SQL query and returns the {@link ResultSet} object generated by the query.
	 * @param sql an SQL statement
	 * @param params the values of parameters in the statement
	 * @param sqlTypes the types of parameters in the statement
	 * @return a {@link ResultSet} object that contains the data produced by the query; never null
	 * @see {@link PreparedStatement#executeQuery()}
	 */
	ResultSet executeQuery(String sql, Object[] params, int[] sqlTypes) throws SQLException;
	/**
	 * Executes the SQL query and returns the {@link ResultSet} object generated by the query.
	 * @param sql an SQL statement
	 * @param paramNames collection of names of parameters in the SQL statement
	 * @param item the object which contains parameters
	 * @return a {@link ResultSet} object that contains the data produced by the query; never null
	 * @see {@link PreparedStatement#executeQuery()}
	 */
	ResultSet executeQuery(String sql, String[] paramNames, Object item) throws SQLException, QueryException;
	/**
	 * Executes an SQL statement and returns the first column of the first row
	 * in the result set generated by the query.
	 * @param sql an SQL statement
	 * @return the first column of the first row in the result set
	 * @throws SQLException
	 */
	Object executeScalar(String sql) throws SQLException;
	/**
	 * Executes an SQL statement and returns the first column of the first row
	 * in the result set generated by the query.
	 * @param sql an SQL statement
	 * @param params the values of parameters in the statement
	 * @return the first column of the first row in the result set
	 * @throws SQLException
	 */
	Object executeScalar(String sql, Object[] params) throws SQLException;
	/**
	 * Executes an SQL statement and returns the first column of the first row
	 * in the result set generated by the query.
	 * @param sql an SQL statement
	 * @param params the values of parameters in the statement
	 * @param sqlTypes the types of parameters in the statement
	 * @return the first column of the first row in the result set
	 * @throws SQLException
	 */
	Object executeScalar(String sql, Object[] params, int[] sqlTypes) throws SQLException;
	/**
	 * Executes an SQL statement and returns the first column of the first row
	 * in the result set generated by the query.
	 * @param sql an SQL statement
	 * @param paramNames collection of names of parameters in the SQL statement
	 * @param item the object which contains parameters
	 * @return the first column of the first row in the result set
	 * @throws SQLException
	 */
	Object executeScalar(String sql, String[] paramNames, Object item) throws SQLException, QueryException;
	/**
	 * Executes an SQL statement and returns the number of rows affected.
	 * Shortcut for {@link PreparedStatement#executeUpdate()}.
	 * @param sql an SQL statement
	 * @return the number of rows affected, or 0 for SQLs that return nothing
	 * @throws SQLException
	 * @see {@link PreparedStatement#executeUpdate()}
	 */
	int executeUpdate(String sql) throws SQLException;
	/**
	 * Executes an SQL statement and returns the number of rows affected.
	 * Shortcut for {@link PreparedStatement#executeUpdate()}.
	 * @param sql an SQL statement
	 * @param params the values of params in the statement
	 * @return the number of rows affected, or 0 for SQLs that return nothing
	 * @throws SQLException
	 */
	int executeUpdate(String sql, Object[] params) throws SQLException;
	/**
	 * Executes an SQL statement and returns the number of rows affected.
	 * Shortcut for {@link PreparedStatement#executeUpdate()}.
	 * @param sql an SQL statement
	 * @param params the values of parameters in the statement
	 * @param sqlTypes the types of parameters in the statement
	 * @return the number of rows affected, or 0 for SQLs that return nothing
	 * @throws SQLException
	 */
	int executeUpdate(String sql, Object[] params, int[] sqlTypes) throws SQLException;
	/**
	 * Executes an SQL statement and returns the number of rows affected.
	 * @param sql an SQL statement
	 * @param paramNames collection of names of parameters in the SQL statement
	 * @param item the object which contains parameters
	 * @return the number of rows affected, or 0 for SQLs that return nothing
	 * @throws SQLException
	 * @throws QueryException if no {@link ValueBinder} is found for the given item
	 */
	int executeUpdate(String sql, String[] paramNames, Object item) throws SQLException, QueryException;

	/**
	 * Checks if the table mapped to the entity exists.
	 * @param entity the name of the entity
	 * @return true if the table mapped to the entity exists, otherwise false
	 */
	boolean existTable(String entity);
	/**
	 * Creates a table mapped to the entity.
	 * @param entity the name of the entity
	 * @throws SQLException
	 */
	void createTable(String entity) throws SQLException;
	/**
	 * Drops a table mapped to the entity.
	 * @param entity the name of the entity
	 * @throws SQLException
	 */
	void dropTable(String entity) throws SQLException;
	/**
	 * Inserts an entity and returns generated identity value if any.
	 * @param entity the name of the entity
	 * @param item the entity to insert
	 * @return the generated identity value if any
	 * @throws SQLException
	 */
	long insert(String entity, Object item) throws SQLException;
	/**
	 * Updates an entity.
	 * @param entity the name of the entity
	 * @param item the entity to update
	 * @return true if updated, false if not found or not modified (for tracked entities)
	 * @throws SQLException
	 */
	boolean update(String entity, Object item) throws SQLException;
	/**
	 * 
	 * Deletes an entity.
	 * @param entity the name of the entity
	 * @param item the entity to delete
	 * @return true if deleted, false if nothing happened
	 * @throws SQLException
	 */
	boolean delete(String entity, Object item) throws SQLException;
	/**
	 * Finds an entity by one or more keys.
	 * @param entity the name of returned entity
	 * @param id the value of primary key(s)
	 * @return an instance of the type, or a default value if nothing is found
	 * @throws SQLException
	 * @throws QueryException if the entity has no primary-key property
	 */
	Object find(String entity, Object id) throws SQLException, QueryException;
	
	/**
	 * Checks if the table mapped to the entity exists.
	 * @param clazz the type of the entity
	 * @return true if the table mapped to the entity exists, otherwise false
	 */
	boolean existTable(Class clazz);
	/**
	 * Creates a table mapped to the entity.
	 * @param clazz the type of the entity
	 * @throws SQLException
	 */
	void createTable(Class clazz) throws SQLException;
	/**
	 * Drops a table mapped to the entity.
	 * @param clazz the type of the entity
	 * @throws SQLException
	 */
	void dropTable(Class clazz) throws SQLException;
	/**
	 * Inserts an entity and returns generated identity value if any.
	 * @param clazz the type of the entity
	 * @param item the entity to insert
	 * @return the generated identity value if any
	 * @throws SQLException
	 */
	long insert(Class clazz, Object item) throws SQLException;
	/**
	 * Updates an entity.
	 * @param clazz the type of the entity
	 * @param item the entity to update
	 * @return true if updated, false if not found or not modified (for tracked entities)
	 * @throws SQLException
	 */
	boolean update(Class clazz, Object item) throws SQLException;
	/**
	 * Deletes an entity.
	 * @param clazz the type of the entity
	 * @param item the entity to delete
	 * @return true if deleted, false if nothing happened
	 * @throws SQLException
	 */
	boolean delete(Class clazz, Object item) throws SQLException;
	/**
	 * Finds an entity by one or more keys. 
	 * @param clazz the type of the returned entity
	 * @param id the value of primary key(s)
	 * @return an instance of the type, or a default value if nothing is found
	 * @throws SQLException
	 * @throws QueryException if the entity has no primary-key property
	 */
	Object find(Class clazz, Object id) throws SQLException, QueryException;
	
	/**
	 * Executes a query and returns list of data.
	 * @param sql the text command to run against the data source
	 * @return a list
	 * @throws SQLException
	 */
	List query(String sql) throws SQLException;
	/**
	 * Executes a query and returns list of data.
	 * @param sql the text command to run against the data source
	 * @param params the values of parameters in the statement
	 * @return a list
	 * @throws SQLException
	 */
	List query(String sql, Object[] params) throws SQLException;
	/**
	 * Executes a query and returns list of data.
	 * @param sql the text command to run against the data source
	 * @param paramNames collection of names of parameters in the SQL statement
	 * @param item the object which contains parameters
	 * @return a list
	 * @throws SQLException
	 */
	List query(String sql, String[] paramNames, Object item) throws SQLException;
	/**
	 * Executes a query and returns list of data.
	 * @param entity the name of returned entities
	 * @param sql the text command to run against the data source
	 * @return a list
	 * @throws SQLException
	 */
	List query(String entity, String sql) throws SQLException;
	/**
	 * Executes a query and returns list of data.
	 * @param entity the name of returned entities
	 * @param sql the text command to run against the data source
	 * @param paramNames the collection of parameters' names
	 * @param item the object which contains parameters
	 * @return a list
	 * @throws SQLException
	 */
	List query(String entity, String sql, String[] paramNames, Object item) throws SQLException;
	/**
	 * Executes a query and returns list of data.
	 * @param entity the name of returned entities
	 * @param sql the text command to run against the data source
	 * @param paramNames the collection of parameters' names
	 * @param item the object which contains parameters
	 * @return a list
	 * @throws SQLException
	 */
	List query(String entity, String sql, Collection paramNames, Object item) throws SQLException;
	/**
	 * Executes a query and returns list of data.
	 * @param clazz the type of returned entities
	 * @param sql the text command to run against the data source
	 * @return a list
	 * @throws SQLException
	 */
	List query(Class clazz, String sql) throws SQLException;
	/**
	 * Executes a query and returns list of data.
	 * @param clazz the type of returned entities
	 * @param sql the text command to run against the data source
	 * @param paramNames the collection of parameters' names
	 * @param item the object which contains parameters
	 * @return a list
	 * @throws SQLException
	 */
	List query(Class clazz, String sql, String[] paramNames, Object item) throws SQLException;
	/**
	 * Executes a query and returns list of data.
	 * @param clazz the type of returned entities
	 * @param sql the text command to run against the data source
	 * @param paramNames the collection of parameters' names
	 * @param item the object which contains parameters
	 * @return a list
	 * @throws SQLException
	 */
	List query(Class clazz, String sql, Collection paramNames, Object item) throws SQLException;

	/**
	 * Creates a criteria query.
	 * @param entity the name of queried entity
	 * @return a {@link ICriteria} to query entities
	 */
	ICriteria createCriteria(String entity);
	/**
	 * Creates a criteria query.
	 * @param clazz the type of queried entity
	 * @return a {@link ICriteria} to query entities
	 */
	ICriteria createCriteria(Class clazz);
}

class ConnectionWrapper implements IConnection {
	private Connection connection;
	private IConnectionFactory factory;
	
	public ConnectionWrapper(Connection connection, IConnectionFactory factory) {
		this.connection = connection;
		this.factory = factory;
	}

	public Connection getConnection() {
		return connection;
	}
	
	public ResultSet executeQuery(String sql) throws SQLException {
		return executeQuery(sql, (Object[]) null, null);
	}
	
	public ResultSet executeQuery(String sql, Object[] params) throws SQLException {
		return executeQuery(sql, params, null);
	}
	
	public ResultSet executeQuery(String sql, Object[] params, int[] sqlTypes) throws SQLException {
		PreparedStatement st = connection.prepareStatement(sql);
		
		if (params != null) {
			if (sqlTypes != null && sqlTypes.length == params.length) {
				for (int i = 0; i < params.length; i++) {
					st.setObject(i + 1, params[i], sqlTypes[i]);
				}
			} else {
				for (int i = 0; i < params.length; i++) {
					st.setObject(i + 1, params[i]);
				}
			}
		}
		
		return new ResultSetWrapper(st.executeQuery(), st);
	}
	
	public ResultSet executeQuery(String sql, String[] paramNames, Object item) throws SQLException {
		return executeQuery(sql, paramNames, null, item);
	}
	
	private ResultSet executeQuery(String sql, String[] paramNames, int[] sqlTypes, Object item) throws SQLException {
		PreparedStatement st = connection.prepareStatement(sql);
		
		if (paramNames != null) {
			ValueBinder binder = getBinder(item.getClass());
			if (sqlTypes == null || sqlTypes.length != paramNames.length) {
				for (int i = 0; i < paramNames.length; i++) {
					binder.bind(st, item, i + 1, paramNames[i], Types.EMPTY);
				}
			} else {
				for (int i = 0; i < paramNames.length; i++) {
					binder.bind(st, item, i + 1, paramNames[i], sqlTypes[i]);
				}
			}
		}
		
		return new ResultSetWrapper(st.executeQuery(), st);
	}
	
	public Object executeScalar(String sql) throws SQLException {
		return executeScalar(sql, (Object[]) null, null);
	}
	
	public Object executeScalar(String sql, Object[] params) throws SQLException {
		return executeScalar(sql, params, null);
	}
	
	public Object executeScalar(String sql, Object[] params, int[] sqlTypes) throws SQLException {
		PreparedStatement st = null;
		
		try {
			st = connection.prepareStatement(sql);
			
			if (params != null) {
				if (sqlTypes != null && sqlTypes.length == params.length) {
					for (int i = 0; i < params.length; i++) {
						st.setObject(i + 1, params[i], sqlTypes[i]);
					}
				} else {
					for (int i = 0; i < params.length; i++) {
						st.setObject(i + 1, params[i]);
					}
				}
			}
			
			ResultSet rs = st.executeQuery();
			try {
				return rs.next() ? rs.getObject(1) : null;
			} finally {
				rs.close();
			}
		} finally {
			if (st != null)
				st.close();
		}
	}
	
	public Object executeScalar(String sql, String[] paramNames, Object item) throws SQLException {
		PreparedStatement st = null;
		try {
			st = connection.prepareStatement(sql);
			
			if (paramNames != null) {
				ValueBinder binder = getBinder(item.getClass());
				for (int i = 0; i < paramNames.length; i++) {
					binder.bind(st, item, i + 1, paramNames[i], Types.EMPTY);
				}
			}
			
			ResultSet rs = st.executeQuery();
			try {
				return rs.next() ? rs.getObject(1) : null;
			} finally {
				rs.close();
			}
		} finally {
			if (st != null)
				st.close();
		}
	}
	
	public int executeUpdate(String sql) throws SQLException {
		return executeUpdate(sql, (Object[]) null, null);
	}
	
	public int executeUpdate(String sql, Object[] params) throws SQLException {
		return executeUpdate(sql, params, null);
	}
	
	public int executeUpdate(String sql, Object[] params, int[] sqlTypes) throws SQLException {
		PreparedStatement st = null;
		
		try {
			st = connection.prepareStatement(sql);
			
			if (params != null) {
				if (sqlTypes != null && sqlTypes.length == params.length) {
					for (int i = 0; i < params.length; i++) {
						st.setObject(i + 1, params[i], sqlTypes[i]);
					}
				} else {
					for (int i = 0; i < params.length; i++) {
						st.setObject(i + 1, params[i]);
					}
				}
			}
			
			return st.executeUpdate();
		} finally {
			if (st != null)
				st.close();
		}
	}
	
	public int executeUpdate(String sql, String[] paramNames, Object item) throws SQLException {
		PreparedStatement st = null;
		try {
			st = connection.prepareStatement(sql);
			
			if (paramNames != null) {
				if (item.getClass().isArray()) {
					int total = 0;
					for (int index = 0, len = java.lang.reflect.Array.getLength(item);
							index < len; index++) {
						Object obj = java.lang.reflect.Array.get(item, index);
						if (obj == null)
							continue;
						ValueBinder binder = getBinder(obj.getClass());
						for (int i = 0; i < paramNames.length; i++) {
							binder.bind(st, obj, i + 1, paramNames[i], Types.EMPTY);
						}
						total += st.executeUpdate();
					}
					return total;
					
				} else if (item instanceof Collection) {
					Collection col = (Collection) item;
					int total = 0;
					
					for (Iterator it = col.iterator(); it.hasNext(); st.clearParameters()) {
						Object obj = it.next();
						if (obj == null)
							continue;
						ValueBinder binder = getBinder(obj.getClass());
						for (int i = 0; i < paramNames.length; i++) {
							binder.bind(st, obj, i + 1, paramNames[i], Types.EMPTY);
						}
						total += st.executeUpdate();
					}
					
					return total;
				} else {
					ValueBinder binder = getBinder(item.getClass());
					for (int i = 0; i < paramNames.length; i++) {
						binder.bind(st, item, i + 1, paramNames[i], Types.EMPTY);
					}
				}
			}
			
			return st.executeUpdate();
		} finally {
			if (st != null)
				st.close();
		}
	}
	
	private ValueBinder getBinder(Class clazz) {
		ValueBinder binder = factory.getBinder(clazz);
		if (binder == null)
			throw new QueryException("No ValueBinder found for " + clazz);
		return binder;
	}
	
	private ValueExtractor getExtractor(Class clazz) {
		ValueExtractor extractor = factory.getExtractor(clazz);
		if (extractor == null)
			throw new QueryException("No ValueExtractor found for " + clazz);
		return extractor;
	}
	
	private int executeUpdate(String sql, Collection paramColumns, Object item) throws SQLException {
		PreparedStatement st = null;
		try {
			st = connection.prepareStatement(sql);
			
			if (paramColumns != null) {
				ValueBinder binder = getBinder(item.getClass());
				int index = 1;
				Iterator it = paramColumns.iterator();
				while (it.hasNext()) {
					Column column = (Column) it.next();
					int dbType = column.getDbType();
					if (dbType == Types.IDENTITY)
						dbType = Types.EMPTY;
					binder.bind(st, item, index++, column.getFieldName(), dbType);
				}
			}
			
			return st.executeUpdate();
		} finally {
			if (st != null)
				st.close();
		}
	}
	
	public List query(String sql) throws SQLException {
		ResultSet rs = executeQuery(sql);
		try {
			return extract(Map.class, null, rs);
		} finally {
			rs.close();
		}
	}
	
	public List query(String sql, Object[] params) throws SQLException {
		ResultSet rs = executeQuery(sql, params);
		try {
			return extract(Map.class, null, rs);
		} finally {
			rs.close();
		}
	}
	
	public List query(String sql, String[] paramNames, Object item) throws SQLException {
		ResultSet rs = executeQuery(sql, paramNames, item);
		try {
			return extract(Map.class, null, rs);
		} finally {
			rs.close();
		}
	}
	
	public List query(String entity, String sql) throws SQLException {
		return query(entity, sql, (String[]) null, null);
	}

	public List query(String entity, String sql, String[] paramNames, Object item) throws SQLException {
		Table table = factory.getMapping().findTable(entity);
		return queryInternal(table == null ? Map.class : table.getEntityClass(), table,
				sql, paramNames, null, item);
	}
	
	public List query(String entity, String sql, Collection paramNames, Object item) throws SQLException {
		Table table = factory.getMapping().findTable(entity);
		return queryInternal(table == null ? Map.class : table.getEntityClass(), table,
				sql, paramNames, null, item);
	}
	
	public List query(Class clazz, String sql) throws SQLException {
		return query(clazz, sql, (String[]) null, null);
	}
	
	public List query(Class clazz, String sql, String[] paramNames, Object item) throws SQLException {
		Table table = factory.getMapping().findTable(clazz);
		return queryInternal(clazz, table, sql, paramNames, null, item);
	}
	
	public List query(Class clazz, String sql, Collection paramNames, Object item) throws SQLException {
		Table table = factory.getMapping().findTable(clazz.getName());
		return queryInternal(clazz, table, sql, paramNames, null, item);
	}
	
	public ICriteria createCriteria(String entity) {
		return new Criteria(entity, this, factory);
	}
	
	public ICriteria createCriteria(Class clazz) {
		return new Criteria(clazz.getName(), this, factory);
	}
	
	private List extract(Class clazz, Table table, ResultSet rs) throws SQLException {
		ValueExtractor extractor = getExtractor(clazz);
		return extractor.extract(rs, table);
	}
	
	private List queryInternal(Class clazz, Table table, String sql,
			Collection paramColumns, Object item) throws SQLException {
		PreparedStatement st = null;
		try {
			st = connection.prepareStatement(sql);
			
			if (paramColumns != null) {
				ValueBinder binder = getBinder(item.getClass());
				int index = 1;
				Iterator it = paramColumns.iterator();
				while (it.hasNext()) {
					Column column = (Column) it.next();
					int dbType = column.getDbType();
					if (dbType == Types.IDENTITY)
						dbType = Types.EMPTY;
					binder.bind(st, item, index++, column.getFieldName(), dbType);
				}
			}
			
			ResultSet rs = st.executeQuery();
			try {
				return extract(clazz, table, rs);
			} finally {
				rs.close();
			}
		} finally {
			if (st != null)
				st.close();
		}
	}
	
	private List queryInternal(Class clazz, Table table, String sql,
			String[] paramNames, int[] paramTypes, Object item) throws SQLException {
		ResultSet rs = executeQuery(sql, paramNames, paramTypes, item);
		return extract(clazz, table, rs);
	}
	
	private List queryInternal(Class clazz, Table table, String sql,
			Collection paramNames, Collection paramTypes, Object item)
			throws SQLException {
		PreparedStatement st = null;
		try {
			st = connection.prepareStatement(sql);
			
			if (paramNames != null) {
				ValueBinder binder = getBinder(item.getClass());
				int index = 1;
				Iterator itName = paramNames.iterator();
				if (paramTypes != null) {
					Iterator itType = paramTypes.iterator();
					while (itName.hasNext() && itType.hasNext()) {
						binder.bind(st, item, index++, (String) itName.next(), ((Integer) itType.next()).intValue());
					}
				} else {
					while (itName.hasNext()) {
						binder.bind(st, item, index++, (String) itName.next(), Types.EMPTY);
					}
				}
			}
			
			ResultSet rs = st.executeQuery();
			try {
				return extract(clazz, table, rs);
			} finally {
				rs.close();
			}
		} finally {
			if (st != null)
				st.close();
		}
	}
	
	public boolean existTable(String entity) {
		return existTable(factory.getMapping().getTable(entity));
	}
	
	public boolean existTable(Class clazz) {
		return existTable(factory.getMapping().getTable(clazz));
	}

	public void createTable(String entity) throws SQLException {
		createTable(factory.getMapping().getTable(entity));
	}
	
	public void createTable(Class clazz) throws SQLException {
		createTable(factory.getMapping().getTable(clazz));
	}

	public void dropTable(String entity) throws SQLException {
		dropTable(factory.getMapping().getTable(entity));
	}

	public void dropTable(Class clazz) throws SQLException {
		dropTable(factory.getMapping().getTable(clazz));
	}
	
	public boolean delete(String entity, Object item) throws SQLException {
		return delete(factory.getMapping().getTable(entity), item);
	}
	
	public boolean delete(Class clazz, Object item) throws SQLException {
		return delete(factory.getMapping().getTable(clazz), item);
	}

	public long insert(String entity, Object item) throws SQLException {
		return insert(factory.getMapping().getTable(entity), item);
	}

	public long insert(Class clazz, Object item) throws SQLException {
		return insert(factory.getMapping().getTable(clazz), item);
	}

	public boolean update(String entity, Object item) throws SQLException {
		return update(factory.getMapping().getTable(entity), item);
	}

	public boolean update(Class clazz, Object item) throws SQLException {
		return update(factory.getMapping().getTable(clazz), item);
	}

	public Object find(String entity, Object id) throws SQLException, QueryException {
		return find(factory.getMapping().getTable(entity), id);
	}
	
	public Object find(Class clazz, Object id) throws SQLException, QueryException {
		return find(factory.getMapping().getTable(clazz), id);
	}

	private boolean existTable(Table table) {
		try {
			executeScalar("select 1 from " + table.getQualifiedName(factory.getDialect(), factory.getMapping().getCatalog(), factory.getMapping().getSchema()));
		} catch (SQLException ex) {
			return false;
		}
		return true;
	}
	
	private void createTable(Table table) throws SQLException {
		String sql = table.toSqlCreate(factory.getDialect(),
				factory.getMapping().getCatalog(), factory.getMapping().getSchema());
		executeUpdate(sql);
	}
	
	private void dropTable(Table table) throws SQLException {
		String sql = table.toSqlDrop(factory.getDialect(),
				factory.getMapping().getCatalog(), factory.getMapping().getSchema());
		executeUpdate(sql);
	}

	private long insert(Table table, Object item) throws SQLException {
		ArrayList paramColumns = new ArrayList();
		String sql = table.toSqlInsert(factory.getDialect(), factory.getMapping().getCatalog(),
				factory.getMapping().getSchema(), paramColumns);
		
		executeUpdate(sql, paramColumns, item);
		
		// select id
		long id = 0L;
		Column idCol = table.getIdColumn();
		if (idCol != null) {
			ValueExtractor extractor = factory.getExtractor(item.getClass());
			if (extractor != null) {
				String idSelectSql = factory.getDialect().getIdentitySelectString(table.getName(),
						idCol.getName(), idCol.getDbType());
				Statement st = null;
				try {
					st = connection.createStatement();
					ResultSet rs = st.executeQuery(idSelectSql);
					if (rs.next()) {
						extractor.extract(rs, item, 1, idCol.getFieldName());
						id = rs.getLong(1);
					}
					rs.close();
				} catch (SQLException ex) {
					// ignore
				} finally {
					if (st != null)
						st.close();
				}
			}
		}
		
		return id;
	}
	
	private boolean update(Table table, Object item) throws SQLException {
		if (!table.hasPrimaryKey())
			throw new QueryException("The type " + table.getName() + " has no primary-key property.");
		
		ArrayList paramColumns = new ArrayList();
		String sql = table.toSqlUpdate(factory.getDialect(),
				factory.getMapping().getCatalog(), factory.getMapping().getSchema(), paramColumns);
		
		return executeUpdate(sql, paramColumns, item) > 0;
	}

	private boolean delete(Table table, Object item) throws SQLException {
		if (!table.hasPrimaryKey())
			throw new QueryException("The type " + table.getName() + " has no primary-key property.");

		ArrayList paramColumns = new ArrayList();
		String sql = table.toSqlDelete(factory.getDialect(),
				factory.getMapping().getCatalog(), factory.getMapping().getSchema(), paramColumns);
		
		return executeUpdate(sql, paramColumns, item) > 0;
	}

	private Object find(Table table, Object id) throws SQLException, QueryException {
		if (!table.hasPrimaryKey())
			throw new QueryException("The type " + table.getName() + " has no primary-key property.");
		
		Object params;
		if (Number.class.isAssignableFrom(id.getClass())
				|| String.class.isAssignableFrom(id.getClass())
				|| Boolean.class.isAssignableFrom(id.getClass())) {
			HashMap map = new HashMap();
			map.put(((Column)table.getPrimaryKey().getColumns().get(0)).getFieldName(), id);
			params = map;
		} else {
			params = id;
		}
		
		ArrayList paramList = new ArrayList();
		String sql = table.toSqlSelect(factory.getDialect(), factory.getMapping().getCatalog(),
				factory.getMapping().getSchema(), true, paramList);
		
		List list = queryInternal(table.getEntityClass(), table, sql, paramList, params);
		return list.size() > 0 ? list.get(0) : null;
	}
	
	public void clearWarnings() throws SQLException {
		connection.clearWarnings();
	}

	public void close() throws SQLException {
		connection.close();
	}

	public void commit() throws SQLException {
		connection.commit();
	}

	public Array createArrayOf(String typeName, Object[] elements)
			throws SQLException {
		return connection.createArrayOf(typeName, elements);
	}

	public Blob createBlob() throws SQLException {
		return connection.createBlob();
	}

	public Clob createClob() throws SQLException {
		return connection.createClob();
	}

	public NClob createNClob() throws SQLException {
		return connection.createNClob();
	}

	public SQLXML createSQLXML() throws SQLException {
		return connection.createSQLXML();
	}

	public Statement createStatement() throws SQLException {
		return connection.createStatement();
	}

	public Statement createStatement(int resultSetType, int resultSetConcurrency)
			throws SQLException {
		return connection.createStatement(resultSetType, resultSetConcurrency);
	}

	public Statement createStatement(int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		return connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
	}

	public Struct createStruct(String typeName, Object[] attributes)
			throws SQLException {
		return connection.createStruct(typeName, attributes);
	}

	public boolean getAutoCommit() throws SQLException {
		return connection.getAutoCommit();
	}

	public String getCatalog() throws SQLException {
		return connection.getCatalog();
	}

	public Properties getClientInfo() throws SQLException {
		return connection.getClientInfo();
	}

	public String getClientInfo(String name) throws SQLException {
		return connection.getClientInfo(name);
	}

	public int getHoldability() throws SQLException {
		return connection.getHoldability();
	}

	public DatabaseMetaData getMetaData() throws SQLException {
		return connection.getMetaData();
	}

	public int getTransactionIsolation() throws SQLException {
		return connection.getTransactionIsolation();
	}

	public Map getTypeMap() throws SQLException {
		return connection.getTypeMap();
	}

	public SQLWarning getWarnings() throws SQLException {
		return connection.getWarnings();
	}

	public boolean isClosed() throws SQLException {
		return connection.isClosed();
	}

	public boolean isReadOnly() throws SQLException {
		return connection.isReadOnly();
	}

	public boolean isValid(int timeout) throws SQLException {
		return connection.isValid(timeout);
	}

	public String nativeSQL(String sql) throws SQLException {
		return connection.nativeSQL(sql);
	}

	public CallableStatement prepareCall(String sql) throws SQLException {
		return connection.prepareCall(sql);
	}

	public CallableStatement prepareCall(String sql, int resultSetType,
			int resultSetConcurrency) throws SQLException {
		return connection.prepareCall(sql, resultSetType, resultSetConcurrency);
	}

	public CallableStatement prepareCall(String sql, int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		return connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
	}

	public PreparedStatement prepareStatement(String sql) throws SQLException {
		return connection.prepareStatement(sql);
	}

	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
			throws SQLException {
		return connection.prepareStatement(sql, autoGeneratedKeys);
	}

	public PreparedStatement prepareStatement(String sql, int[] columnIndexes)
			throws SQLException {
		return connection.prepareStatement(sql, columnIndexes);
	}

	public PreparedStatement prepareStatement(String sql, String[] columnNames)
			throws SQLException {
		return connection.prepareStatement(sql, columnNames);
	}

	public PreparedStatement prepareStatement(String sql, int resultSetType,
			int resultSetConcurrency) throws SQLException {
		return connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
	}

	public PreparedStatement prepareStatement(String sql, int resultSetType,
			int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		return connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
	}

	public void releaseSavepoint(Savepoint savepoint) throws SQLException {
		connection.releaseSavepoint(savepoint);
	}

	public void rollback() throws SQLException {
		connection.rollback();
	}

	public void rollback(Savepoint savepoint) throws SQLException {
		connection.rollback(savepoint);
	}

	public void setAutoCommit(boolean autoCommit) throws SQLException {
		connection.setAutoCommit(autoCommit);
	}

	public void setCatalog(String catalog) throws SQLException {
		connection.setCatalog(catalog);
	}

	public void setClientInfo(Properties properties)
			throws SQLClientInfoException {
		connection.setClientInfo(properties);
	}

	public void setClientInfo(String name, String value)
			throws SQLClientInfoException {
		connection.setClientInfo(name, value);
	}

	public void setHoldability(int holdability) throws SQLException {
		connection.setHoldability(holdability);		
	}

	public void setReadOnly(boolean readOnly) throws SQLException {
		connection.setReadOnly(readOnly);
	}

	public Savepoint setSavepoint() throws SQLException {
		return connection.setSavepoint();
	}

	public Savepoint setSavepoint(String name) throws SQLException {
		return connection.setSavepoint(name);
	}

	public void setTransactionIsolation(int level) throws SQLException {
		connection.setTransactionIsolation(level);
	}

	public void setTypeMap(Map arg0) throws SQLException {
		connection.setTypeMap(arg0);
	}

	public boolean isWrapperFor(Class arg0) throws SQLException {
		return connection.isWrapperFor(arg0);
	}

	public void setSchema(String schema) throws SQLException {
		connection.setSchema(schema);
	}

	public String getSchema() throws SQLException {
		return connection.getSchema();
	}

	public void abort(java.util.concurrent.Executor executor) throws SQLException {
		connection.abort(executor);
	}

	public void setNetworkTimeout(java.util.concurrent.Executor executor, int milliseconds)
			throws SQLException {
		connection.setNetworkTimeout(executor, milliseconds);
	}

	public int getNetworkTimeout() throws SQLException {
		return connection.getNetworkTimeout();
	}

	public Object unwrap(Class iface) throws SQLException {
		return connection.unwrap(iface);
	}
}

class ResultSetWrapper implements ResultSet {
	private final ResultSet rs;
	private final Statement st;
	
	public ResultSetWrapper(ResultSet rs, Statement st) {
		this.rs = rs;
		this.st = st;
	}

	public Object unwrap(Class iface) throws SQLException {
		return rs.unwrap(iface);
	}

	public boolean isWrapperFor(Class iface) throws SQLException {
		return rs.isWrapperFor(iface);
	}

	public boolean next() throws SQLException {
		return rs.next();
	}

	public void close() throws SQLException {
		try {
			rs.close();
		} finally {
			st.close();
		}
	}

	public boolean wasNull() throws SQLException {
		return rs.wasNull();
	}

	public String getString(int columnIndex) throws SQLException {
		return rs.getString(columnIndex);
	}

	public boolean getBoolean(int columnIndex) throws SQLException {
		return rs.getBoolean(columnIndex);
	}

	public byte getByte(int columnIndex) throws SQLException {
		return rs.getByte(columnIndex);
	}

	public short getShort(int columnIndex) throws SQLException {
		return rs.getShort(columnIndex);
	}

	public int getInt(int columnIndex) throws SQLException {
		return rs.getInt(columnIndex);
	}

	public long getLong(int columnIndex) throws SQLException {
		return rs.getLong(columnIndex);
	}

	public float getFloat(int columnIndex) throws SQLException {
		return rs.getFloat(columnIndex);
	}

	public double getDouble(int columnIndex) throws SQLException {
		return rs.getDouble(columnIndex);
	}

	/**
	 * @deprecated
	 */
	public BigDecimal getBigDecimal(int columnIndex, int scale)
			throws SQLException {
		return rs.getBigDecimal(columnIndex, scale);
	}

	public byte[] getBytes(int columnIndex) throws SQLException {
		return rs.getBytes(columnIndex);
	}

	public Date getDate(int columnIndex) throws SQLException {
		return rs.getDate(columnIndex);
	}

	public Time getTime(int columnIndex) throws SQLException {
		return rs.getTime(columnIndex);
	}

	public Timestamp getTimestamp(int columnIndex) throws SQLException {
		return rs.getTimestamp(columnIndex);
	}

	public InputStream getAsciiStream(int columnIndex) throws SQLException {
		return rs.getAsciiStream(columnIndex);
	}

	/**
	 * @deprecated
	 */
	public InputStream getUnicodeStream(int columnIndex) throws SQLException {
		return rs.getUnicodeStream(columnIndex);
	}

	public InputStream getBinaryStream(int columnIndex) throws SQLException {
		return rs.getBinaryStream(columnIndex);
	}

	public String getString(String columnLabel) throws SQLException {
		return rs.getString(columnLabel);
	}

	public boolean getBoolean(String columnLabel) throws SQLException {
		return rs.getBoolean(columnLabel);
	}

	public byte getByte(String columnLabel) throws SQLException {
		return rs.getByte(columnLabel);
	}

	public short getShort(String columnLabel) throws SQLException {
		return rs.getShort(columnLabel);
	}

	public int getInt(String columnLabel) throws SQLException {
		return rs.getInt(columnLabel);
	}

	public long getLong(String columnLabel) throws SQLException {
		return rs.getLong(columnLabel);
	}

	public float getFloat(String columnLabel) throws SQLException {
		return rs.getFloat(columnLabel);
	}

	public double getDouble(String columnLabel) throws SQLException {
		return rs.getDouble(columnLabel);
	}

	/**
	 * @deprecated
	 */
	public BigDecimal getBigDecimal(String columnLabel, int scale)
			throws SQLException {
		return rs.getBigDecimal(columnLabel, scale);
	}

	public byte[] getBytes(String columnLabel) throws SQLException {
		return rs.getBytes(columnLabel);
	}

	public Date getDate(String columnLabel) throws SQLException {
		return rs.getDate(columnLabel);
	}

	public Time getTime(String columnLabel) throws SQLException {
		return rs.getTime(columnLabel);
	}

	public Timestamp getTimestamp(String columnLabel) throws SQLException {
		return rs.getTimestamp(columnLabel);
	}

	public InputStream getAsciiStream(String columnLabel) throws SQLException {
		return rs.getAsciiStream(columnLabel);
	}
	
	/**
	 * @deprecated
	 */
	public InputStream getUnicodeStream(String columnLabel) throws SQLException {
		return rs.getUnicodeStream(columnLabel);
	}

	public InputStream getBinaryStream(String columnLabel) throws SQLException {
		return rs.getBinaryStream(columnLabel);
	}

	public SQLWarning getWarnings() throws SQLException {
		return rs.getWarnings();
	}

	public void clearWarnings() throws SQLException {
		rs.clearWarnings();
	}

	public String getCursorName() throws SQLException {
		return rs.getCursorName();
	}

	public ResultSetMetaData getMetaData() throws SQLException {
		return rs.getMetaData();
	}

	public Object getObject(int columnIndex) throws SQLException {
		return rs.getObject(columnIndex);
	}

	public Object getObject(String columnLabel) throws SQLException {
		return rs.getObject(columnLabel);
	}

	public int findColumn(String columnLabel) throws SQLException {
		return rs.findColumn(columnLabel);
	}

	public Reader getCharacterStream(int columnIndex) throws SQLException {
		return rs.getCharacterStream(columnIndex);
	}

	public Reader getCharacterStream(String columnLabel) throws SQLException {
		return rs.getCharacterStream(columnLabel);
	}

	public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
		return rs.getBigDecimal(columnIndex);
	}

	public BigDecimal getBigDecimal(String columnLabel) throws SQLException {
		return rs.getBigDecimal(columnLabel);
	}

	public boolean isBeforeFirst() throws SQLException {
		return rs.isBeforeFirst();
	}

	public boolean isAfterLast() throws SQLException {
		return rs.isAfterLast();
	}

	public boolean isFirst() throws SQLException {
		return rs.isFirst();
	}

	public boolean isLast() throws SQLException {
		return rs.isLast();
	}

	public void beforeFirst() throws SQLException {
		rs.beforeFirst();
	}

	public void afterLast() throws SQLException {
		rs.afterLast();
	}

	public boolean first() throws SQLException {
		return rs.first();
	}

	public boolean last() throws SQLException {
		return rs.last();
	}

	public int getRow() throws SQLException {
		return rs.getRow();
	}

	public boolean absolute(int row) throws SQLException {
		return rs.absolute(row);
	}

	public boolean relative(int rows) throws SQLException {
		return rs.relative(rows);
	}

	public boolean previous() throws SQLException {
		return rs.previous();
	}

	public void setFetchDirection(int direction) throws SQLException {
		rs.setFetchDirection(direction);
	}

	public int getFetchDirection() throws SQLException {
		return rs.getFetchDirection();
	}

	public void setFetchSize(int rows) throws SQLException {
		rs.setFetchSize(rows);
	}

	public int getFetchSize() throws SQLException {
		return rs.getFetchSize();
	}

	public int getType() throws SQLException {
		return rs.getType();
	}

	public int getConcurrency() throws SQLException {
		return rs.getConcurrency();
	}

	public boolean rowUpdated() throws SQLException {
		return rs.rowUpdated();
	}

	public boolean rowInserted() throws SQLException {
		return rs.rowInserted();
	}

	public boolean rowDeleted() throws SQLException {
		return rs.rowDeleted();
	}

	public void updateNull(int columnIndex) throws SQLException {
		rs.updateNull(columnIndex);
	}

	public void updateBoolean(int columnIndex, boolean x) throws SQLException {
		rs.updateBoolean(columnIndex, x);
	}

	public void updateByte(int columnIndex, byte x) throws SQLException {
		rs.updateByte(columnIndex, x);
	}

	public void updateShort(int columnIndex, short x) throws SQLException {
		rs.updateShort(columnIndex, x);
	}

	public void updateInt(int columnIndex, int x) throws SQLException {
		rs.updateInt(columnIndex, x);
	}

	public void updateLong(int columnIndex, long x) throws SQLException {
		rs.updateLong(columnIndex, x);
	}

	public void updateFloat(int columnIndex, float x) throws SQLException {
		rs.updateFloat(columnIndex, x);
	}

	public void updateDouble(int columnIndex, double x) throws SQLException {
		rs.updateDouble(columnIndex, x);
	}

	public void updateBigDecimal(int columnIndex, BigDecimal x)
			throws SQLException {
		rs.updateBigDecimal(columnIndex, x);
	}

	public void updateString(int columnIndex, String x) throws SQLException {
		rs.updateString(columnIndex, x);
	}

	public void updateBytes(int columnIndex, byte[] x) throws SQLException {
		rs.updateBytes(columnIndex, x);
	}

	public void updateDate(int columnIndex, Date x) throws SQLException {
		rs.updateDate(columnIndex, x);
	}

	public void updateTime(int columnIndex, Time x) throws SQLException {
		rs.updateTime(columnIndex, x);
	}

	public void updateTimestamp(int columnIndex, Timestamp x)
			throws SQLException {
		rs.updateTimestamp(columnIndex, x);
	}

	public void updateAsciiStream(int columnIndex, InputStream x, int length)
			throws SQLException {
		rs.updateAsciiStream(columnIndex, x);
	}

	public void updateBinaryStream(int columnIndex, InputStream x, int length)
			throws SQLException {
		rs.updateBinaryStream(columnIndex, x);
	}

	public void updateCharacterStream(int columnIndex, Reader x, int length)
			throws SQLException {
		rs.updateCharacterStream(columnIndex, x);
	}

	public void updateObject(int columnIndex, Object x, int scaleOrLength)
			throws SQLException {
		rs.updateObject(columnIndex, x);
	}

	public void updateObject(int columnIndex, Object x) throws SQLException {
		rs.updateObject(columnIndex, x);
	}

	public void updateNull(String columnLabel) throws SQLException {
		rs.updateNull(columnLabel);
	}

	public void updateBoolean(String columnLabel, boolean x)
			throws SQLException {
		rs.updateBoolean(columnLabel, x);
	}

	public void updateByte(String columnLabel, byte x) throws SQLException {
		rs.updateByte(columnLabel, x);
	}

	public void updateShort(String columnLabel, short x) throws SQLException {
		rs.updateShort(columnLabel, x);
	}

	public void updateInt(String columnLabel, int x) throws SQLException {
		rs.updateInt(columnLabel, x);
	}

	public void updateLong(String columnLabel, long x) throws SQLException {
		rs.updateLong(columnLabel, x);
	}

	public void updateFloat(String columnLabel, float x) throws SQLException {
		rs.updateFloat(columnLabel, x);
	}

	public void updateDouble(String columnLabel, double x) throws SQLException {
		rs.updateDouble(columnLabel, x);
	}

	public void updateBigDecimal(String columnLabel, BigDecimal x)
			throws SQLException {
		rs.updateBigDecimal(columnLabel, x);
	}

	public void updateString(String columnLabel, String x) throws SQLException {
		rs.updateString(columnLabel, x);
	}

	public void updateBytes(String columnLabel, byte[] x) throws SQLException {
		rs.updateBytes(columnLabel, x);
	}

	public void updateDate(String columnLabel, Date x) throws SQLException {
		rs.updateDate(columnLabel, x);
	}

	public void updateTime(String columnLabel, Time x) throws SQLException {
		rs.updateTime(columnLabel, x);
	}

	public void updateTimestamp(String columnLabel, Timestamp x)
			throws SQLException {
		rs.updateTimestamp(columnLabel, x);
	}

	public void updateAsciiStream(String columnLabel, InputStream x, int length)
			throws SQLException {
		rs.updateAsciiStream(columnLabel, x);
	}

	public void updateBinaryStream(String columnLabel, InputStream x, int length)
			throws SQLException {
		rs.updateBinaryStream(columnLabel, x);
	}

	public void updateCharacterStream(String columnLabel, Reader reader,
			int length) throws SQLException {
		rs.updateCharacterStream(columnLabel, reader, length);
	}

	public void updateObject(String columnLabel, Object x, int scaleOrLength)
			throws SQLException {
		rs.updateObject(columnLabel, x);
	}

	public void updateObject(String columnLabel, Object x) throws SQLException {
		rs.updateObject(columnLabel, x);
	}

	public void insertRow() throws SQLException {
		rs.insertRow();
	}

	public void updateRow() throws SQLException {
		rs.updateRow();
	}

	public void deleteRow() throws SQLException {
		rs.deleteRow();
	}

	public void refreshRow() throws SQLException {
		rs.refreshRow();		
	}

	public void cancelRowUpdates() throws SQLException {
		rs.cancelRowUpdates();
	}

	public void moveToInsertRow() throws SQLException {
		rs.moveToInsertRow();
	}

	public void moveToCurrentRow() throws SQLException {
		rs.moveToCurrentRow();
	}

	public Statement getStatement() throws SQLException {
		return rs.getStatement();
	}

	public Object getObject(int columnIndex, Map map) throws SQLException {
		return rs.getObject(columnIndex, map);
	}

	public Ref getRef(int columnIndex) throws SQLException {
		return rs.getRef(columnIndex);
	}

	public Blob getBlob(int columnIndex) throws SQLException {
		return rs.getBlob(columnIndex);
	}

	public Clob getClob(int columnIndex) throws SQLException {
		return rs.getClob(columnIndex);
	}

	public Array getArray(int columnIndex) throws SQLException {
		return rs.getArray(columnIndex);
	}

	public Object getObject(String columnLabel, Map map) throws SQLException {
		return rs.getObject(columnLabel, map);
	}

	public Ref getRef(String columnLabel) throws SQLException {
		return rs.getRef(columnLabel);
	}

	public Blob getBlob(String columnLabel) throws SQLException {
		return rs.getBlob(columnLabel);
	}

	public Clob getClob(String columnLabel) throws SQLException {
		return rs.getClob(columnLabel);
	}

	public Array getArray(String columnLabel) throws SQLException {
		return rs.getArray(columnLabel);
	}

	public Date getDate(int columnIndex, Calendar cal) throws SQLException {
		return rs.getDate(columnIndex, cal);
	}

	public Date getDate(String columnLabel, Calendar cal) throws SQLException {
		return rs.getDate(columnLabel, cal);
	}

	public Time getTime(int columnIndex, Calendar cal) throws SQLException {
		return rs.getTime(columnIndex, cal);
	}

	public Time getTime(String columnLabel, Calendar cal) throws SQLException {
		return rs.getTime(columnLabel, cal);
	}

	public Timestamp getTimestamp(int columnIndex, Calendar cal)
			throws SQLException {
		return rs.getTimestamp(columnIndex, cal);
	}

	public Timestamp getTimestamp(String columnLabel, Calendar cal)
			throws SQLException {
		return rs.getTimestamp(columnLabel, cal);
	}

	public URL getURL(int columnIndex) throws SQLException {
		return rs.getURL(columnIndex);
	}

	public URL getURL(String columnLabel) throws SQLException {
		return rs.getURL(columnLabel);
	}

	public void updateRef(int columnIndex, Ref x) throws SQLException {
		rs.updateRef(columnIndex, x);
	}

	public void updateRef(String columnLabel, Ref x) throws SQLException {
		rs.updateRef(columnLabel, x);
	}

	public void updateBlob(int columnIndex, Blob x) throws SQLException {
		rs.updateBlob(columnIndex, x);
	}

	public void updateBlob(String columnLabel, Blob x) throws SQLException {
		rs.updateBlob(columnLabel, x);
	}

	public void updateClob(int columnIndex, Clob x) throws SQLException {
		rs.updateClob(columnIndex, x);
	}

	public void updateClob(String columnLabel, Clob x) throws SQLException {
		rs.updateClob(columnLabel, x);
	}

	public void updateArray(int columnIndex, Array x) throws SQLException {
		rs.updateArray(columnIndex, x);
	}

	public void updateArray(String columnLabel, Array x) throws SQLException {
		rs.updateArray(columnLabel, x);
	}

	public RowId getRowId(int columnIndex) throws SQLException {
		return rs.getRowId(columnIndex);
	}

	public RowId getRowId(String columnLabel) throws SQLException {
		return rs.getRowId(columnLabel);
	}

	public void updateRowId(int columnIndex, RowId x) throws SQLException {
		rs.updateRowId(columnIndex, x);		
	}

	public void updateRowId(String columnLabel, RowId x) throws SQLException {
		rs.updateRowId(columnLabel, x);
	}

	public int getHoldability() throws SQLException {
		return rs.getHoldability();
	}

	public boolean isClosed() throws SQLException {
		return rs.isClosed();
	}

	public void updateNString(int columnIndex, String nString)
			throws SQLException {
		rs.updateNString(columnIndex, nString);
	}

	public void updateNString(String columnLabel, String nString)
			throws SQLException {
		rs.updateNString(columnLabel, nString);
	}

	public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
		rs.updateNClob(columnIndex, nClob);
	}

	public void updateNClob(String columnLabel, NClob nClob)
			throws SQLException {
		rs.updateNClob(columnLabel, nClob);
	}

	public NClob getNClob(int columnIndex) throws SQLException {
		return rs.getNClob(columnIndex);
	}

	public NClob getNClob(String columnLabel) throws SQLException {
		return rs.getNClob(columnLabel);
	}

	public SQLXML getSQLXML(int columnIndex) throws SQLException {
		return rs.getSQLXML(columnIndex);
	}

	public SQLXML getSQLXML(String columnLabel) throws SQLException {
		return rs.getSQLXML(columnLabel);
	}

	public void updateSQLXML(int columnIndex, SQLXML xmlObject)
			throws SQLException {
		rs.updateSQLXML(columnIndex, xmlObject);
	}

	public void updateSQLXML(String columnLabel, SQLXML xmlObject)
			throws SQLException {
		rs.updateSQLXML(columnLabel, xmlObject);
	}

	public String getNString(int columnIndex) throws SQLException {
		return rs.getNString(columnIndex);
	}

	public String getNString(String columnLabel) throws SQLException {
		return rs.getNString(columnLabel);
	}

	public Reader getNCharacterStream(int columnIndex) throws SQLException {
		return rs.getNCharacterStream(columnIndex);
	}

	public Reader getNCharacterStream(String columnLabel) throws SQLException {
		return rs.getNCharacterStream(columnLabel);
	}

	public void updateNCharacterStream(int columnIndex, Reader x, long length)
			throws SQLException {
		rs.updateNCharacterStream(columnIndex, x, length);
	}

	public void updateNCharacterStream(String columnLabel, Reader reader,
			long length) throws SQLException {
		rs.updateNCharacterStream(columnLabel, reader, length);
	}

	public void updateAsciiStream(int columnIndex, InputStream x, long length)
			throws SQLException {
		rs.updateAsciiStream(columnIndex, x, length);
	}

	public void updateBinaryStream(int columnIndex, InputStream x, long length)
			throws SQLException {
		rs.updateBinaryStream(columnIndex, x, length);
	}

	public void updateCharacterStream(int columnIndex, Reader x, long length)
			throws SQLException {
		rs.updateCharacterStream(columnIndex, x, length);
	}

	public void updateAsciiStream(String columnLabel, InputStream x, long length)
			throws SQLException {
		rs.updateAsciiStream(columnLabel, x, length);
	}

	public void updateBinaryStream(String columnLabel, InputStream x,
			long length) throws SQLException {
		rs.updateBinaryStream(columnLabel, x, length);
	}

	public void updateCharacterStream(String columnLabel, Reader reader,
			long length) throws SQLException {
		rs.updateCharacterStream(columnLabel, reader, length);		
	}

	public void updateBlob(int columnIndex, InputStream inputStream, long length)
			throws SQLException {
		rs.updateBlob(columnIndex, inputStream, length);
	}

	public void updateBlob(String columnLabel, InputStream inputStream,
			long length) throws SQLException {
		rs.updateBlob(columnLabel, inputStream, length);
	}

	public void updateClob(int columnIndex, Reader reader, long length)
			throws SQLException {
		rs.updateClob(columnIndex, reader, length);
	}

	public void updateClob(String columnLabel, Reader reader, long length)
			throws SQLException {
		rs.updateClob(columnLabel, reader, length);
	}

	public void updateNClob(int columnIndex, Reader reader, long length)
			throws SQLException {
		rs.updateNClob(columnIndex, reader, length);
	}

	public void updateNClob(String columnLabel, Reader reader, long length)
			throws SQLException {
		rs.updateNClob(columnLabel, reader, length);
	}

	public void updateNCharacterStream(int columnIndex, Reader x)
			throws SQLException {
		rs.updateNCharacterStream(columnIndex, x);
	}

	public void updateNCharacterStream(String columnLabel, Reader reader)
			throws SQLException {
		rs.updateNCharacterStream(columnLabel, reader);
	}

	public void updateAsciiStream(int columnIndex, InputStream x)
			throws SQLException {
		rs.updateAsciiStream(columnIndex, x);
	}

	public void updateBinaryStream(int columnIndex, InputStream x)
			throws SQLException {
		rs.updateBinaryStream(columnIndex, x);
	}

	public void updateCharacterStream(int columnIndex, Reader x)
			throws SQLException {
		rs.updateCharacterStream(columnIndex, x);
	}

	public void updateAsciiStream(String columnLabel, InputStream x)
			throws SQLException {
		rs.updateAsciiStream(columnLabel, x);
	}

	public void updateBinaryStream(String columnLabel, InputStream x)
			throws SQLException {
		rs.updateBinaryStream(columnLabel, x);
	}

	public void updateCharacterStream(String columnLabel, Reader reader)
			throws SQLException {
		rs.updateCharacterStream(columnLabel, reader);
	}

	public void updateBlob(int columnIndex, InputStream inputStream)
			throws SQLException {
		rs.updateBlob(columnIndex, inputStream);
	}

	public void updateBlob(String columnLabel, InputStream inputStream)
			throws SQLException {
		rs.updateBlob(columnLabel, inputStream);
	}

	public void updateClob(int columnIndex, Reader reader) throws SQLException {
		rs.updateClob(columnIndex, reader);
	}

	public void updateClob(String columnLabel, Reader reader)
			throws SQLException {
		rs.updateClob(columnLabel, reader);
	}

	public void updateNClob(int columnIndex, Reader reader) throws SQLException {
		rs.updateNClob(columnIndex, reader);
	}

	public void updateNClob(String columnLabel, Reader reader)
			throws SQLException {
		rs.updateNClob(columnLabel, reader);
	}

	public Object getObject(int columnIndex, Class type) throws SQLException {
		return rs.getObject(columnIndex, type);
	}

	public Object getObject(String columnLabel, Class type) throws SQLException {
		return rs.getObject(columnLabel, type);
	}
	
}